<!DOCTYPE html>
<html lang="ru">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>–õ–ò–ù–ò–ò –†–ê–ó–£–ú–ê</title>
    <script src="https://unpkg.com/@vkontakte/vk-bridge/dist/browser.min.js"></script>
    <style>
      body {
        font-family: Arial, sans-serif;
        display: flex;
        flex-direction: column;
        align-items: center;
        padding: 20px;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        min-height: 100vh;
      }
      h1 {
        font-size: 48px;
        font-weight: bold;
        color: #fff;
        margin-bottom: 10px;
        text-shadow: 3px 3px 6px rgba(0, 0, 0, 0.3);
        letter-spacing: 4px;
      }
      #level-info {
        font-size: 18px;
        margin-bottom: 20px;
        color: #fff;
        font-weight: 500;
      }
      #game-container {
        background: white;
        padding: 20px;
        border-radius: 10px;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        display: flex;
        flex-direction: column;
        align-items: center;
      }
      #game-canvas {
        border: 2px solid #333;
        cursor: crosshair;
        touch-action: none;
      }
      #controls {
        margin-top: 20px;
        display: flex;
        flex-direction: column;
        gap: 10px;
        width: 490px;
      }
      button {
        padding: 12px 20px;
        font-size: 16px;
        cursor: pointer;
        border: none;
        border-radius: 8px;
        color: white;
        transition: all 0.3s;
        font-weight: 500;
        width: 100%;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
      }
      #undo-btn {
        background: linear-gradient(135deg, #ffa726 0%, #ff9800 100%);
      }
      #undo-btn:hover {
        background: linear-gradient(135deg, #ff9800 0%, #f57c00 100%);
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        transform: translateY(-2px);
      }
      #clear-btn {
        background: linear-gradient(135deg, #ec407a 0%, #e91e63 100%);
      }
      #clear-btn:hover {
        background: linear-gradient(135deg, #e91e63 0%, #d81b60 100%);
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        transform: translateY(-2px);
      }
      button:disabled {
        background: #ccc;
        cursor: not-allowed;
        box-shadow: none;
        transform: none;
      }
      #message {
        margin-top: 15px;
        font-size: 18px;
        font-weight: bold;
        color: #4caf50;
        min-height: 25px;
      }
      #rules {
        margin-top: 20px;
        padding: 15px;
        background: #f9f9f9;
        border-radius: 8px;
        max-width: 490px;
        font-size: 14px;
        line-height: 1.6;
        color: #333;
      }
      #rules h3 {
        margin-top: 0;
        margin-bottom: 10px;
        color: #667eea;
        font-size: 16px;
      }
      #rules ul {
        margin: 5px 0;
        padding-left: 20px;
      }
      #rules li {
        margin-bottom: 5px;
      }
      #rules p {
        margin: 8px 0;
      }
    </style>
  </head>
  <body>
    <h1>–õ–ò–ù–ò–ò –†–ê–ó–£–ú–ê</h1>
    <div id="level-info">–£—Ä–æ–≤–µ–Ω—å: <span id="current-level">1</span></div>
    <div id="game-container">
      <canvas id="game-canvas" width="490" height="490"></canvas>
      <div id="controls">
        <button id="undo-btn">–û—Ç–º–µ–Ω–∏—Ç—å –ø–æ—Å–ª–µ–¥–Ω–µ–µ –¥–µ–π—Å—Ç–≤–∏–µ</button>
        <button id="clear-btn">–û—á–∏—Å—Ç–∏—Ç—å –ø–æ–ª–µ</button>
      </div>
      <div id="message"></div>
      <div id="rules">
        <h3>üìã –ü—Ä–∞–≤–∏–ª–∞ –∏–≥—Ä—ã:</h3>
        <ul>
          <li>–ù–∞—á–Ω–∏—Ç–µ —Å –∫–ª–µ—Ç–∫–∏ —Å —Ü–∏—Ñ—Ä–æ–π <strong>1</strong></li>
          <li>
            –ü—Ä–æ–≤–µ–¥–∏—Ç–µ –ª–∏–Ω–∏—é –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ —á–µ—Ä–µ–∑ —Ü–∏—Ñ—Ä—ã
            <strong>1‚Üí2‚Üí3‚Üí...‚Üí9</strong>
          </li>
          <li>–õ–∏–Ω–∏—è –¥–æ–ª–∂–Ω–∞ –∑–∞–ø–æ–ª–Ω–∏—Ç—å <strong>–≤—Å–µ 49 –∫–ª–µ—Ç–æ–∫</strong> –ø–æ–ª—è</li>
          <li>
            –ü–µ—Ä–µ—Ö–æ–¥–∏—Ç–µ —Ç–æ–ª—å–∫–æ –Ω–∞ <strong>—Å–æ—Å–µ–¥–Ω–∏–µ –∫–ª–µ—Ç–∫–∏</strong> (–≤–≤–µ—Ä—Ö, –≤–Ω–∏–∑,
            –≤–ª–µ–≤–æ, –≤–ø—Ä–∞–≤–æ)
          </li>
          <li>–ù–µ–ª—å–∑—è –ø—Ä–æ—Ö–æ–¥–∏—Ç—å –¥–≤–∞–∂–¥—ã —á–µ—Ä–µ–∑ –æ–¥–Ω—É –∫–ª–µ—Ç–∫—É</li>
        </ul>
        <p>
          <strong>üí° –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ:</strong> –†–∏—Å—É–π—Ç–µ –ª–∏–Ω–∏—é –º—ã—à—å—é –∏–ª–∏ –ø–∞–ª—å—Ü–µ–º,
          —É–¥–µ—Ä–∂–∏–≤–∞—è –∫–Ω–æ–ø–∫—É –Ω–∞–∂–∞—Ç–æ–π. –ö—Ä–∞—Å–Ω–∞—è –ª–∏–Ω–∏—è –æ–∑–Ω–∞—á–∞–µ—Ç –æ—à–∏–±–∫—É!
        </p>
      </div>
    </div>

    <script>
      const canvas = document.getElementById("game-canvas");
      const ctx = canvas.getContext("2d");
      const undoBtn = document.getElementById("undo-btn");
      const clearBtn = document.getElementById("clear-btn");
      const messageDiv = document.getElementById("message");
      const levelSpan = document.getElementById("current-level");

      const GRID_SIZE = 7;
      const CELL_SIZE = 70;
      const AD_FORMAT = "interstitial";
      const STORAGE_KEY = "lines_of_mind_level";

      let gameData = [];
      let currentRound = 0;
      let currentGrid = [];
      let path = [];
      let isDrawing = false;
      let numbers = [];
      let gameBlocked = false;
      let errorSegmentIndex = -1;
      let adCheckIntervalId = null;

      function isBridgeAvailable() {
        return typeof window !== "undefined" && window.vkBridge;
      }

      async function checkNativeAds() {
        if (!isBridgeAvailable()) {
          return;
        }

        try {
          await window.vkBridge.send("VKWebAppCheckNativeAds", {
            ad_format: AD_FORMAT,
          });
        } catch (error) {
          console.error("–ù–µ —É–¥–∞–ª–æ—Å—å –≤—ã–ø–æ–ª–Ω–∏—Ç—å VKWebAppCheckNativeAds", error);
        }
      }

      async function showInterstitialAd() {
        if (!isBridgeAvailable()) {
          return;
        }

        try {
          const response = await window.vkBridge.send("VKWebAppShowNativeAds", {
            ad_format: AD_FORMAT,
          });

          if (!response?.result) {
            console.warn("–ü–æ–∫–∞–∑ interstitial-—Ä–µ–∫–ª–∞–º—ã –Ω–µ —É–¥–∞–ª—Å—è", response);
          }
        } catch (error) {
          console.error("–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–∫–∞–∑–µ interstitial-—Ä–µ–∫–ª–∞–º—ã", error);
        }
      }

      async function loadSavedLevel() {
        if (!isBridgeAvailable()) {
          return 1;
        }

        try {
          const response = await window.vkBridge.send("VKWebAppStorageGet", {
            keys: [STORAGE_KEY],
          });

          if (response.keys && response.keys.length > 0) {
            const savedLevel = parseInt(response.keys[0].value, 10);
            if (!isNaN(savedLevel) && savedLevel >= 1 && savedLevel <= 100) {
              console.log("–ó–∞–≥—Ä—É–∂–µ–Ω —Å–æ—Ö—Ä–∞–Ω—ë–Ω–Ω—ã–π —É—Ä–æ–≤–µ–Ω—å:", savedLevel);
              return savedLevel;
            }
          }
        } catch (error) {
          console.error("–û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ —É—Ä–æ–≤–Ω—è –∏–∑ VK Storage", error);
        }

        return 1;
      }

      async function saveCurrentLevel(level) {
        if (!isBridgeAvailable()) {
          return;
        }

        try {
          await window.vkBridge.send("VKWebAppStorageSet", {
            key: STORAGE_KEY,
            value: level.toString(),
          });
          console.log("–£—Ä–æ–≤–µ–Ω—å —Å–æ—Ö—Ä–∞–Ω—ë–Ω:", level);
        } catch (error) {
          console.error("–û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–∏ —É—Ä–æ–≤–Ω—è –≤ VK Storage", error);
        }
      }

      async function initAds() {
        if (!isBridgeAvailable()) {
          return;
        }

        try {
          await window.vkBridge.send("VKWebAppInit");
        } catch (error) {
          console.error("VKWebAppInit –∑–∞–≤–µ—Ä—à–∏–ª—Å—è —Å –æ—à–∏–±–∫–æ–π", error);
        }

        await checkNativeAds();

        if (adCheckIntervalId === null) {
          adCheckIntervalId = setInterval(checkNativeAds, 60_000);
        }
      }

      const gameDataJSON = [
        {
          round_id: 1,
          grid: [
            [1, null, null, null, null, null, 2],
            [null, 4, null, 3, null, null, null],
            [null, null, null, null, null, null, null],
            [null, null, null, null, null, null, null],
            [null, null, 9, 8, 7, null, 6],
            [null, null, null, null, null, null, null],
            [null, null, 5, null, null, null, null],
          ],
        },
        {
          round_id: 2,
          grid: [
            [1, null, null, null, null, null, null],
            [null, null, null, null, 8, null, 6],
            [null, null, null, 9, null, 7, null],
            [null, null, null, 5, null, null, null],
            [null, null, null, null, 3, null, 4],
            [null, null, null, null, null, null, 2],
            [null, null, null, null, null, null, null],
          ],
        },
        {
          round_id: 3,
          grid: [
            [1, null, null, null, null, null, 2],
            [null, null, null, null, null, 6, null],
            [null, null, 7, null, null, null, 3],
            [null, null, null, null, null, 8, null],
            [null, null, null, null, null, null, null],
            [null, 9, null, null, null, null, null],
            [5, null, null, null, 4, null, null],
          ],
        },
        {
          round_id: 4,
          grid: [
            [null, 8, null, 7, null, null, null],
            [null, null, null, null, null, null, null],
            [null, null, null, 6, null, 5, null],
            [null, null, null, null, null, null, 4],
            [null, 9, null, 3, null, null, null],
            [null, null, null, null, null, null, null],
            [null, null, 2, null, 1, null, null],
          ],
        },
        {
          round_id: 5,
          grid: [
            [null, null, null, null, null, null, null],
            [5, null, null, null, null, 4, null],
            [null, null, null, 8, 3, null, null],
            [null, null, null, null, null, null, 2],
            [null, null, null, 9, 1, null, null],
            [null, null, null, 7, null, null, null],
            [null, 6, null, null, null, null, null],
          ],
        },
        {
          round_id: 6,
          grid: [
            [null, 6, null, null, null, null, null],
            [null, null, 7, 8, null, null, null],
            [null, null, null, null, null, null, null],
            [null, null, null, null, null, null, null],
            [5, null, null, 9, null, 3, null],
            [4, null, null, null, null, null, 2],
            [null, null, null, null, null, null, 1],
          ],
        },
        {
          round_id: 7,
          grid: [
            [null, null, null, null, null, null, null],
            [9, null, null, null, null, 8, 7],
            [1, null, null, null, 6, null, null],
            [null, null, null, null, null, null, null],
            [null, null, 5, null, null, null, null],
            [null, 4, null, null, null, null, null],
            [null, null, 2, 3, null, null, null],
          ],
        },
        {
          round_id: 8,
          grid: [
            [null, null, 9, null, null, null, null],
            [null, null, 8, null, null, null, null],
            [null, null, null, 7, null, null, null],
            [null, null, null, null, null, 3, null],
            [null, 6, null, null, null, null, null],
            [4, null, null, null, 5, null, 2],
            [null, null, null, null, null, null, 1],
          ],
        },
        {
          round_id: 9,
          grid: [
            [null, null, 3, 2, null, null, null],
            [4, null, null, null, null, null, null],
            [null, null, 6, null, null, null, null],
            [null, null, null, null, 8, null, null],
            [null, null, null, null, null, null, 1],
            [5, null, null, 7, null, null, null],
            [null, null, null, null, null, 9, null],
          ],
        },
        {
          round_id: 10,
          grid: [
            [null, null, null, null, 3, null, null],
            [2, 8, 7, null, null, null, null],
            [1, null, null, null, null, null, null],
            [null, null, null, null, null, 6, null],
            [null, null, 9, null, null, null, null],
            [5, null, null, null, null, null, 4],
            [null, null, null, null, null, null, null],
          ],
        },
      ];

      function loadGameData() {
        gameData = gameDataJSON;
      }

      async function loadLevel(roundId) {
        const round = gameData.find((r) => r.round_id === roundId);
        if (!round) {
          messageDiv.textContent = "–ü–æ–∑–¥—Ä–∞–≤–ª—è–µ–º! –í—ã –ø—Ä–æ—à–ª–∏ –≤—Å–µ —É—Ä–æ–≤–Ω–∏!";
          return;
        }

        currentRound = roundId;
        currentGrid = round.grid;
        levelSpan.textContent = roundId;

        numbers = [];
        for (let row = 0; row < GRID_SIZE; row++) {
          for (let col = 0; col < GRID_SIZE; col++) {
            const value = currentGrid[row][col];
            if (value !== null) {
              numbers.push({ value, row, col });
            }
          }
        }
        numbers.sort((a, b) => a.value - b.value);

        clearGame();
        drawGrid();
      }

      function clearGame() {
        path = [];
        gameBlocked = false;
        errorSegmentIndex = -1;
        messageDiv.textContent = "";
        drawGrid();
      }

      function drawGrid() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        ctx.strokeStyle = "#ddd";
        ctx.lineWidth = 1;
        for (let i = 0; i <= GRID_SIZE; i++) {
          ctx.beginPath();
          ctx.moveTo(i * CELL_SIZE, 0);
          ctx.lineTo(i * CELL_SIZE, GRID_SIZE * CELL_SIZE);
          ctx.stroke();

          ctx.beginPath();
          ctx.moveTo(0, i * CELL_SIZE);
          ctx.lineTo(GRID_SIZE * CELL_SIZE, i * CELL_SIZE);
          ctx.stroke();
        }

        if (path.length > 0) {
          ctx.lineCap = "round";
          ctx.lineJoin = "round";
          ctx.lineWidth = 4;

          if (errorSegmentIndex === -1 || errorSegmentIndex > 0) {
            ctx.strokeStyle = "#2196F3";
            ctx.beginPath();
            ctx.moveTo(
              path[0].col * CELL_SIZE + CELL_SIZE / 2,
              path[0].row * CELL_SIZE + CELL_SIZE / 2
            );
            const endIndex =
              errorSegmentIndex === -1 ? path.length : errorSegmentIndex + 1;
            for (let i = 1; i < endIndex; i++) {
              ctx.lineTo(
                path[i].col * CELL_SIZE + CELL_SIZE / 2,
                path[i].row * CELL_SIZE + CELL_SIZE / 2
              );
            }
            ctx.stroke();
          }

          if (errorSegmentIndex !== -1 && errorSegmentIndex < path.length - 1) {
            ctx.strokeStyle = "#f44336";
            ctx.beginPath();
            ctx.moveTo(
              path[errorSegmentIndex].col * CELL_SIZE + CELL_SIZE / 2,
              path[errorSegmentIndex].row * CELL_SIZE + CELL_SIZE / 2
            );
            ctx.lineTo(
              path[errorSegmentIndex + 1].col * CELL_SIZE + CELL_SIZE / 2,
              path[errorSegmentIndex + 1].row * CELL_SIZE + CELL_SIZE / 2
            );
            ctx.stroke();
          }
        }

        ctx.font = "bold 24px Arial";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        for (let row = 0; row < GRID_SIZE; row++) {
          for (let col = 0; col < GRID_SIZE; col++) {
            const value = currentGrid[row][col];
            if (value !== null) {
              const pathIndex = path.findIndex(
                (p) => p.row === row && p.col === col
              );
              const isInPath = pathIndex !== -1;

              let color = "#333";

              if (isInPath) {
                if (value === 1) {
                  color = "#2196F3";
                } else {
                  if (
                    errorSegmentIndex !== -1 &&
                    pathIndex === errorSegmentIndex + 1
                  ) {
                    color = "#f44336";
                  } else {
                    color = "#4CAF50";
                  }
                }
              }

              ctx.fillStyle = color;
              ctx.fillText(
                value,
                col * CELL_SIZE + CELL_SIZE / 2,
                row * CELL_SIZE + CELL_SIZE / 2
              );
            }
          }
        }
      }

      function getCellFromEvent(e) {
        const rect = canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        const col = Math.floor(x / CELL_SIZE);
        const row = Math.floor(y / CELL_SIZE);

        if (row >= 0 && row < GRID_SIZE && col >= 0 && col < GRID_SIZE) {
          return { row, col };
        }
        return null;
      }

      function isAdjacent(cell1, cell2) {
        const rowDiff = Math.abs(cell1.row - cell2.row);
        const colDiff = Math.abs(cell1.col - cell2.col);
        return (
          (rowDiff === 1 && colDiff === 0) || (rowDiff === 0 && colDiff === 1)
        );
      }

      function getExpectedNumber() {
        if (path.length === 0) return 1;

        let maxFound = 0;
        for (const cell of path) {
          const value = currentGrid[cell.row][cell.col];
          if (value !== null && value > maxFound) {
            maxFound = value;
          }
        }
        return maxFound + 1;
      }

      function checkVictoryCondition() {
        // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –≤—Å–µ –ª–∏ –∫–ª–µ—Ç–∫–∏ –∑–∞–ø–æ–ª–Ω–µ–Ω—ã
        if (path.length !== GRID_SIZE * GRID_SIZE) {
          console.log(
            "–ü–æ–±–µ–¥–∞ –ù–ï –¥–æ—Å—Ç–∏–≥–Ω—É—Ç–∞: –∑–∞–ø–æ–ª–Ω–µ–Ω–æ " +
              path.length +
              " –∏–∑ " +
              GRID_SIZE * GRID_SIZE +
              " –∫–ª–µ—Ç–æ–∫"
          );
          return false;
        }

        // –°–æ–±–∏—Ä–∞–µ–º –≤—Å–µ —á–∏—Å–ª–∞ –∏–∑ –ø—É—Ç–∏
        const numbersInPath = new Set();
        for (const p of path) {
          const val = currentGrid[p.row][p.col];
          if (val !== null) {
            numbersInPath.add(val);
          }
        }

        // –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞–ª–∏—á–∏–µ –≤—Å–µ—Ö —á–∏—Å–µ–ª –æ—Ç 1 –¥–æ 9
        const missingNumbers = [];
        for (let i = 1; i <= 9; i++) {
          if (!numbersInPath.has(i)) {
            missingNumbers.push(i);
          }
        }

        if (missingNumbers.length > 0) {
          console.log(
            "–ü–æ–±–µ–¥–∞ –ù–ï –¥–æ—Å—Ç–∏–≥–Ω—É—Ç–∞: –æ—Ç—Å—É—Ç—Å—Ç–≤—É—é—Ç —á–∏—Å–ª–∞ " +
              missingNumbers.join(", ")
          );
          return false;
        }

        console.log("–ü–û–ë–ï–î–ê –î–û–°–¢–ò–ì–ù–£–¢–ê!");
        return true;
      }

      function addCellToPath(cell) {
        if (gameBlocked) return false;

        if (path.length === 0) {
          const value = currentGrid[cell.row][cell.col];
          if (value !== 1) {
            return false;
          }
        }

        if (path.length > 0) {
          const lastCell = path[path.length - 1];
          if (!isAdjacent(lastCell, cell)) {
            return false;
          }
        }

        if (path.some((p) => p.row === cell.row && p.col === cell.col)) {
          return false;
        }

        const cellValue = currentGrid[cell.row][cell.col];
        const expectedNum = getExpectedNumber();

        if (cellValue !== null) {
          if (cellValue !== expectedNum) {
            errorSegmentIndex = path.length - 1;
            path.push(cell);
            gameBlocked = true;
            messageDiv.textContent = "–û—à–∏–±–∫–∞! –ù–∞—Ä—É—à–µ–Ω–∞ –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ—Å—Ç—å.";
            messageDiv.style.color = "#f44336";
            drawGrid();
            return false;
          }
        }

        path.push(cell);
        drawGrid();

        // –ü—Ä–æ–≤–µ—Ä—è–µ–º –ø–æ–±–µ–¥—É –Ω–∞ –∫–∞–∂–¥–æ–º —Ö–æ–¥–µ
        const isVictory = checkVictoryCondition();

        if (isVictory) {
          gameBlocked = true;
          messageDiv.textContent = "–£—Ä–æ–≤–µ–Ω—å –ø—Ä–æ–π–¥–µ–Ω! –ó–∞–≥—Ä—É–∂–∞–µ–º —Å–ª–µ–¥—É—é—â–∏–π...";
          messageDiv.style.color = "#4CAF50";

          const nextLevel = currentRound + 1;
          saveCurrentLevel(nextLevel);

          setTimeout(() => {
            showInterstitialAd().finally(() => {
              loadLevel(nextLevel);
            });
          }, 1500);
          return true;
        }

        return true;
      }

      canvas.addEventListener("mousedown", (e) => {
        if (gameBlocked) return;
        const cell = getCellFromEvent(e);
        if (cell) {
          isDrawing = true;
          addCellToPath(cell);
        }
      });

      canvas.addEventListener("mousemove", (e) => {
        if (!isDrawing || gameBlocked) return;
        const cell = getCellFromEvent(e);
        if (cell) {
          addCellToPath(cell);
        }
      });

      canvas.addEventListener("mouseup", () => {
        isDrawing = false;
      });

      canvas.addEventListener("mouseleave", () => {
        isDrawing = false;
      });

      canvas.addEventListener("touchstart", (e) => {
        e.preventDefault();
        if (gameBlocked) return;
        const touch = e.touches[0];
        const mouseEvent = new MouseEvent("mousedown", {
          clientX: touch.clientX,
          clientY: touch.clientY,
        });
        canvas.dispatchEvent(mouseEvent);
      });

      canvas.addEventListener("touchmove", (e) => {
        e.preventDefault();
        const touch = e.touches[0];
        const mouseEvent = new MouseEvent("mousemove", {
          clientX: touch.clientX,
          clientY: touch.clientY,
        });
        canvas.dispatchEvent(mouseEvent);
      });

      canvas.addEventListener("touchend", (e) => {
        e.preventDefault();
        isDrawing = false;
      });

      undoBtn.addEventListener("click", () => {
        if (path.length > 0) {
          path.pop();
          gameBlocked = false;
          errorSegmentIndex = -1;
          messageDiv.textContent = "";
          drawGrid();
        }

        showInterstitialAd();
      });

      clearBtn.addEventListener("click", () => {
        clearGame();
        showInterstitialAd();
      });

      async function initGame() {
        await initAds();
        loadGameData();
        const savedLevel = await loadSavedLevel();
        loadLevel(savedLevel);
      }

      initGame();
    </script>
  </body>
</html>
